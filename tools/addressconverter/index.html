<!DOCTYPE html>
<html>
<head>
  <title>Ark Address Tools</title>
</head>
<body>
  <h1>Ark Address ⇄ ScriptPubKey Converter</h1>
<p>This tool converts Ark addresses to Script Hex and vice versa, based on the ArkLabs mainnet node public key, which is currently <b>034ae8492184a8ca64cf5299a5eefcb59d1c8e41668e667dfd4d042e5876d34745</b>. 
<br>The node is temporarily hosted on <a href="https://bitcoin-beta.arkade.sh" target="_blank">https://bitcoin-beta.arkade.sh</a>.
<br>Note: this tool is experimental. The node public key and URL can change.</pS>
  <!-- Section 1: Ark Address → ScriptPubKey -->
  <h2>1. Ark Address to ScriptPubKey (Hex)</h2>

  <label for="arkAddress">Ark Address:</label><br>
  <input type="text" id="arkAddress" size="90"><br><br>

  <button onclick="arkToScript()">Convert</button><br><br>

  <label for="scriptHex">ScriptPubKey (Hex):</label><br>
  <textarea id="scriptHex" rows="2" cols="90" readonly></textarea>

  <hr>

  <!-- Section 2: ScriptPubKey → Ark Address -->
  <h2>2. ScriptPubKey (Hex) + Server Pubkey → Ark Address</h2>

  <label for="scriptInput">ScriptPubKey (Hex):</label><br>
  <input type="text" id="scriptInput" size="90"><br><br>

  <label for="serverPubkey">Server Pubkey (compressed hex, 33 bytes):</label><br>
  <input type="text" id="serverPubkey" size="70" value="034ae8492184a8ca64cf5299a5eefcb59d1c8e41668e667dfd4d042e5876d34745"><br><br>

  <button onclick="scriptToArk()">Convert</button><br><br>

  <label for="arkOutput">Reconstructed Ark Address:</label><br>
  <textarea id="arkOutput" rows="2" cols="90" readonly></textarea>

  <script>
    // Bech32m and hex utils
    const CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

    function fromWords(words) {
      let acc = 0, bits = 0;
      const result = [];
      for (let value of words) {
        acc = (acc << 5) | value;
        bits += 5;
        while (bits >= 8) {
          bits -= 8;
          result.push((acc >> bits) & 0xff);
        }
      }
      return new Uint8Array(result);
    }

    function toWords(bytes) {
      let acc = 0, bits = 0;
      const words = [];
      for (let byte of bytes) {
        acc = (acc << 8) | byte;
        bits += 8;
        while (bits >= 5) {
          bits -= 5;
          words.push((acc >> bits) & 31);
        }
      }
      if (bits > 0) {
        words.push((acc << (5 - bits)) & 31);
      }
      return words;
    }

    function toHex(bytes) {
      return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
    }

    function bech32mDecode(bech) {
      const sep = bech.lastIndexOf('1');
      if (sep === -1) throw new Error("Missing separator");
      const hrp = bech.substring(0, sep);
      const data = bech.substring(sep + 1).split('').map(c => {
        const v = CHARSET.indexOf(c);
        if (v === -1) throw new Error("Invalid character: " + c);
        return v;
      });
      return { hrp, data };
    }

    function bech32mEncode(hrp, data) {
      function polymod(values) {
        const GEN = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];
        let chk = 1;
        for (let v of values) {
          let top = chk >> 25;
          chk = ((chk & 0x1ffffff) << 5) ^ v;
          for (let i = 0; i < 5; i++) {
            if ((top >> i) & 1) chk ^= GEN[i];
          }
        }
        return chk ^ 0x2bc830a3;
      }

      function expandHrp(hrp) {
        const ret = [];
        for (let i = 0; i < hrp.length; i++) ret.push(hrp.charCodeAt(i) >> 5);
        ret.push(0);
        for (let i = 0; i < hrp.length; i++) ret.push(hrp.charCodeAt(i) & 31);
        return ret;
      }

      const values = toWords(data);
      const checksum = polymod([...expandHrp(hrp), ...values, 0, 0, 0, 0, 0, 0]);
      const chk = [];
      for (let i = 0; i < 6; i++) chk.push((checksum >> (5 * (5 - i))) & 31);
      const combined = [...values, ...chk];
      return hrp + '1' + combined.map(v => CHARSET[v]).join('');
    }

    function arkToScript() {
      const input = document.getElementById("arkAddress").value.trim();
      const output = document.getElementById("scriptHex");

      try {
        const { data } = bech32mDecode(input);
        const full = fromWords(data);
        const decoded = full.slice(0, 65); // Strip padding

        if (decoded.length !== 65) {
          output.value = "Invalid Ark address: incorrect length.";
          return;
        }

        const taprootKey = decoded.slice(33);
        const scriptHex = "5120" + toHex(taprootKey);
        output.value = scriptHex;
      } catch (e) {
        output.value = "Error: " + e.message;
      }
    }

    function scriptToArk() {
      const scriptHex = document.getElementById("scriptInput").value.trim();
      const serverHex = document.getElementById("serverPubkey").value.trim();
      const output = document.getElementById("arkOutput");

      try {
        if (!scriptHex.startsWith("5120") || scriptHex.length !== 68) {
          output.value = "Invalid scriptPubKey format.";
          return;
        }

        const taprootHex = scriptHex.slice(4);
        const taprootKey = Uint8Array.from(taprootHex.match(/.{2}/g).map(b => parseInt(b, 16)));

        if (serverHex.length !== 66 || !/^0[2-3]/.test(serverHex)) {
          output.value = "Invalid server pubkey.";
          return;
        }

        const serverKey = Uint8Array.from(serverHex.slice(2).match(/.{2}/g).map(b => parseInt(b, 16)));

        const payload = new Uint8Array([0, ...serverKey, ...taprootKey]);
        const arkAddress = bech32mEncode("ark", payload);
        output.value = arkAddress;
      } catch (e) {
        output.value = "Error: " + e.message;
      }
    }
  </script>
</body>
</html>

