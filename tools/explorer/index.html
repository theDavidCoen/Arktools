<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>Arkade Transaction Explorer (CORS-friendly)</title>
</head>
<body>
<h1>Arkade Transaction Explorer</h1>

<h3>Search by Transaction ID (txid + vout)</h3>
<label>Txid:</label><br />
<input id="txid" size="70" placeholder="Enter txid (64 hex chars)" /><br />
<label>Vout (output index):</label><br />
<input id="vout" type="number" min="0" value="0" /><br />
<button onclick="fetchByTxid()">Fetch by Txid</button>

<hr>

<h3>Or search by ScriptPubKey (hex)</h3>
<input id="scriptHex" size="90" placeholder="Enter scriptPubKey hex" /><br />
<button onclick="fetchByScript()">Fetch by Script</button>

<hr>

<div id="result" style="white-space: pre-wrap; font-family: monospace; margin-top:20px;"></div>

<script>
const serverPubkey = "034ae8492184a8ca64cf5299a5eefcb59d1c8e41668e667dfd4d042e5876d34745";
const CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

function fromWords(words) {
  let acc = 0, bits = 0;
  const result = [];
  for (let value of words) {
    acc = (acc << 5) | value;
    bits += 5;
    while (bits >= 8) {
      bits -= 8;
      result.push((acc >> bits) & 0xff);
    }
  }
  return new Uint8Array(result);
}

function toWords(bytes) {
  let acc = 0, bits = 0;
  const words = [];
  for (let byte of bytes) {
    acc = (acc << 8) | byte;
    bits += 8;
    while (bits >= 5) {
      bits -= 5;
      words.push((acc >> bits) & 31);
    }
  }
  if (bits > 0) {
    words.push((acc << (5 - bits)) & 31);
  }
  return words;
}

function bech32mEncode(hrp, data) {
  function polymod(values) {
    const GEN = [0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];
    let chk = 1;
    for (let v of values) {
      let top = chk >> 25;
      chk = ((chk & 0x1ffffff) << 5) ^ v;
      for(let i=0;i<5;i++) {
        if(((top>>i)&1) === 1) chk ^= GEN[i];
      }
    }
    return chk ^ 0x2bc830a3;
  }
  function expandHrp(hrp) {
    const ret = [];
    for(let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i)>>5);
    ret.push(0);
    for(let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i)&31);
    return ret;
  }
  const values = toWords(data);
  const checksum = polymod([...expandHrp(hrp), ...values, 0,0,0,0,0,0]);
  const chk = [];
  for(let i=0;i<6;i++) chk.push((checksum>>(5*(5-i)))&31);
  const combined = [...values,...chk];
  return hrp + '1' + combined.map(v=>CHARSET[v]).join('');
}

function scriptToArkAddress(scriptHex) {
  if (!scriptHex.startsWith("5120") || scriptHex.length !== 68) return null;
  const taprootHex = scriptHex.slice(4);
  const taprootKey = Uint8Array.from(taprootHex.match(/.{2}/g).map(b => parseInt(b,16)));

  if (serverPubkey.length !== 66 || !/^0[23]/.test(serverPubkey)) return null;
  const serverKey = Uint8Array.from(serverPubkey.slice(2).match(/.{2}/g).map(b => parseInt(b,16)));

  const payload = new Uint8Array([0, ...serverKey, ...taprootKey]);
  return bech32mEncode("ark", payload);
}

async function fetchByTxid() {
  const txid = document.getElementById('txid').value.trim();
  const vout = document.getElementById('vout').value.trim();
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Loading...";

  if (!txid.match(/^[0-9a-f]{64}$/i)) {
    resultDiv.textContent = "Invalid txid format. Must be 64 hex chars.";
    return;
  }
  if (isNaN(vout) || vout < 0) {
    resultDiv.textContent = "Invalid vout. Must be a non-negative integer.";
    return;
  }

  const url = `https://bitcoin-beta.arkade.sh/v1/vtxos?outpoints=${txid}:${vout}`;
  try {
    const resp = await fetch(url);
    if(!resp.ok) throw new Error("HTTP " + resp.status);
    const json = await resp.json();

    if(!json.vtxos || json.vtxos.length === 0) {
      resultDiv.textContent = "No data found for given txid and vout.";
      return;
    }
    const vtxo = json.vtxos[0];
    resultDiv.textContent = formatVtxo(vtxo);
  } catch(e) {
    resultDiv.textContent = "Error fetching data: "+e.message;
  }
}

async function fetchByScript() {
  const script = document.getElementById('scriptHex').value.trim();
  const resultDiv = document.getElementById('result');
  resultDiv.textContent = "Loading...";

  if(!/^[0-9a-f]+$/i.test(script)) {
    resultDiv.textContent = "Script must be hex only.";
    return;
  }

  const url = `https://bitcoin-beta.arkade.sh/v1/vtxos?scripts=${script}`;
  try {
    const resp = await fetch(url);
    if(!resp.ok) throw new Error("HTTP " + resp.status);
    const json = await resp.json();

    if(!json.vtxos || json.vtxos.length === 0) {
      resultDiv.textContent = "No data found for given script.";
      return;
    }

    // Build and show all vtxo data
    resultDiv.textContent = json.vtxos.map(vtxo => formatVtxo(vtxo)).join("\n\n---------------------\n\n");
  } catch(e) {
    resultDiv.textContent = "Error fetching data: "+e.message;
  }
}

function formatVtxo(vtxo) {
  const { outpoint, arkTxid, amount, script, isSpent, isSwept, spentBy, createdAt, expiresAt } = vtxo;
  const receiver = scriptToArkAddress(script) || "Unknown";
  const sender = spentBy || "N/A";
  const created = new Date(parseInt(createdAt) * 1000).toLocaleString();
  const expires = new Date(parseInt(expiresAt) * 1000).toLocaleString();

  return `
TxID:           ${outpoint.txid}
Vout:           ${outpoint.vout}
Ark TxID:       ${arkTxid || 'N/A'}
Amount:         ${amount} sats
Receiver:       ${receiver}
Sender (SpentBy): ${sender}
Is Spent:       ${isSpent ? "Yes" : "No"}
Is Swept:       ${isSwept ? "Yes" : "No"}
Created At:     ${created}
Expires At:     ${expires}
Script (hex):   ${script}`.trim();
}
</script>
</body>
</html>

