<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Ark Explorer â€” Proto version</title>
  <style>
    @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;600&display=swap');
    body { font-family: 'Inter', Arial, sans-serif; background:#f6f7fb; color:#111; margin:20px; }
    header { display: flex; align-items: center; gap: 12px; margin-bottom: 24px; }
    header img { height: 32px; width: auto; user-select: none; }
    header h1 { font-weight: 600; font-size: 28px; margin: 0; color: #0F172A; }
    #search { width: 60%; padding: 8px; font-size: 14px; border: 1px solid #d1d5db; border-radius: 6px; outline-offset: 2px; outline-color: #2563eb; transition: outline-color 0.2s ease; }
    #search:focus { outline-color: #3b82f6; }
    button { padding: 8px 12px; margin-left: 6px; background: #2563eb; border: none; color: white; font-weight: 600; border-radius: 6px; cursor: pointer; transition: background-color 0.2s ease; }
    button:hover { background: #1e40af; }
    label { margin-left: 8px; font-size: 13px; user-select: none; cursor: pointer; color: #374151; }
    .result { background: #fff; padding: 16px; margin-top: 18px; border-radius: 10px; box-shadow: 0 6px 18px rgba(20,20,40,0.04); }
    table { width: 100%; border-collapse: collapse; margin-top: 12px; }
    th, td { text-align: left; padding: 8px 6px; border-bottom: 1px solid #eee; font-size: 13px; }
    th { background: #fbfbfd; font-weight: 600; }
    .muted { color: #666; font-size: 13px; }
    .loading { color: #888; }
    small.note { color: #666; display: block; margin-top: 6px; }
    .chevron { cursor: pointer; }
    .hidden { display: none; }
  .description {
  background: #f9f9fb;
  padding: 16px;
  border-radius: 10px;
  margin-top: 20px;
  box-shadow: 0 4px 12px rgba(0, 0, 0, 0.05);
}

.toggle-more button {
  background: #2563eb;
  border: none;
  color: white;
  font-weight: 600;
  border-radius: 6px;
  cursor: pointer;
  margin-top: 10px;
  padding: 8px 16px;
}

.toggle-more .hidden {
  display: none;
}

.toggle-more ul {
  margin-top: 10px;
  color: #333;
}

.toggle-more ul li {
  margin-bottom: 6px;
}
  </style>
</head>
<body>
  <header>
    <img src="https://mintlify.s3.us-west-1.amazonaws.com/arkade/logo/light.svg" alt="Arkade Logo" />
    <h1>Explorer</h1>
  </header>  
  <div class="description">
  <h2>About Arkade Explorer</h2>
  <p>Arkade Explorer is a web-based tool that allows users to explore and query Arkade addresses, scripts, and transaction IDs. It's built with the help of LLMs and is currently using the demo wallet <b>riga.arkade.money</b> and the demo arkd server public key: <b>034ae8492184a8ca64cf5299a5eefcb59d1c8e41668e667dfd4d042e5876d34745</b>.</p>
  
<h3>Features & Capabilities</h3>
      <ul>
        <li><b>Advanced Search Tools:</b> Effortlessly enter addresses, scripts, or transaction IDs for detailed querying functionalities.</li>
        <li><b>Dynamic Filtering Options:</b> Toggle between displaying spendable vTXOs or organizing results by unique commitments for a tailored view.</li>
        <li><b>Streamlined Interface:</b> Utilize collapsible views that allow you to expand or collapse groups, maintaining a tidy workspace.</li>
        <li><b>Integrated External Links:</b> Seamlessly link to detailed transaction views on external platforms such as mempool.space for enriched insights.</li>
      </ul>
      <p><b>Project Overview:</b> As an open-source project, Arkade Explorer invites collaboration and creativity. While it's in a non-final version, the tool aims to offer a playful yet insightful exploration of Arkade data. Contributions and feedback are warmly welcomed to help shape its evolution.</p>
      <p><b>Usage Note:</b> Please remember that this tool is for demonstration purposes and might contain developmental quirks.
<br><b>Github Repo:</b> <a href="https://github.com/theDavidCoen/Arktools/tree/main/tools/explorer" target="_blank">https://github.com/theDavidCoen/Arktools/tree/main/tools/explorer</a>
</p>
  </div>
<br>
<div class="toggle-more">
    <button onclick="toggleDescription()">Customize node parameters</button>
    <div id="moreDescription" class="hidden">
           <ul>
        <li><b>Node base URL:</b> <input id="nodeBase" placeholder="Enter NODE_BASE"/></li>
        <li><b>Server Public Key:</b> <input id="serverPubKey" placeholder="Enter SERVER_PUBKEY"/></li>
        <li><b>VTXO Endpoint:</b> <input id="vtxosEndpoint" placeholder="Enter VTXOS_ENDPOINT"/></li>
    <button id="confirmButton">Confirm Custom Variables</button>
    <button id="resetButton">Reset to Default</button>
    </div>
  </div>
</div>
<br>
  <input id="search" placeholder="Enter txid (64 hex), script (5120...), or Ark address (ark1...)" />
  <button onclick="explore()">Search</button>
  <label><input type="checkbox" id="spendableOnly" checked onchange="refreshBalance()"> Only spendable</label>
  <label><input type="checkbox" id="groupByCommitment" onchange="refreshBalance()"> Group by commitment transaction</label>
  
  <div class="result" id="output" style="display:none"></div>

<script>
// Define variables outside the function to make them accessible globally
      let NODE_BASE, VTXOS_ENDPOINT, SERVER_PUBKEY;

      document.addEventListener('DOMContentLoaded', function () {
          const DEFAULT_NODE_BASE = "https://bitcoin-beta.arkade.sh";
          const DEFAULT_SERVER_PUBKEY = "034ae8492184a8ca64cf5299a5eefcb59d1c8e41668e667dfd4d042e5876d34745";

          const nodeBaseInput = document.getElementById('nodeBase');
          const serverPubKeyInput = document.getElementById('serverPubKey');
          const vtxosEndpointInput = document.getElementById('vtxosEndpoint');
          const confirmButton = document.getElementById('confirmButton');
          const resetButton = document.getElementById('resetButton');
          const searchButton = document.getElementById('searchButton');

          function updateVariables() {
              // Update values based on user input or fallback to default values
              NODE_BASE = nodeBaseInput.value.trim() || DEFAULT_NODE_BASE;
              SERVER_PUBKEY = serverPubKeyInput.value.trim() || DEFAULT_SERVER_PUBKEY;
              VTXOS_ENDPOINT = vtxosEndpointInput.value.trim() || `${NODE_BASE}/v1/vtxos`;

              // Log the values for verification
              console.log('Using NODE_BASE:', NODE_BASE);
              console.log('Using SERVER_PUBKEY:', SERVER_PUBKEY);
              console.log('Using VTXOS_ENDPOINT:', VTXOS_ENDPOINT);
          }

          confirmButton.addEventListener('click', function() {
              // Update the variables based on the current inputs
              updateVariables();
              alert('Custom variables confirmed');
          });

          resetButton.addEventListener('click', function() {
              // Reset inputs to default values
              nodeBaseInput.value = DEFAULT_NODE_BASE;
              serverPubKeyInput.value = DEFAULT_SERVER_PUBKEY;
              vtxosEndpointInput.value = `${DEFAULT_NODE_BASE}/v1/vtxos`;
              updateVariables();
              alert('Variables reset to default');
          });

          searchButton.addEventListener('click', function() {
              // Ensure the latest input or confirmed values are used in search
              updateVariables();

              // Perform your search logic here using the updated values
              // Example: fetch(VTXOS_ENDPOINT).then(...);
          });
      });
const CHARSET = "qpzry9x8gf2tvdw0s3jn54khce6mua7l";

function toggleDescription() {
  const moreDesc = document.getElementById("moreDescription");
  moreDesc.classList.toggle("hidden");
}
function fromWords(words) {
  let acc = 0, bits = 0;
  const result = [];
  for (let value of words) {
    acc = (acc << 5) | value;
    bits += 5;
    while (bits >= 8) {
      bits -= 8;
      result.push((acc >> bits) & 0xff);
    }
  }
  return new Uint8Array(result);
}
function toWords(bytes) {
  let acc = 0, bits = 0, words = [];
  for (let byte of bytes) {
    acc = (acc << 8) | byte;
    bits += 8;
    while (bits >= 5) {
      bits -= 5;
      words.push((acc >> bits) & 31);
    }
  }
  if (bits > 0) words.push((acc << (5 - bits)) & 31);
  return words;
}
function toHex(bytes) { return Array.from(bytes).map(b => b.toString(16).padStart(2,'0')).join(''); }
function bech32mDecode(bech) {
  const sep = bech.lastIndexOf('1');
  if (sep === -1) throw new Error("Invalid bech32m: missing separator");
  const hrp = bech.substring(0, sep);
  const data = bech.substring(sep+1).split('').map(c => {
    const v = CHARSET.indexOf(c);
    if (v === -1) throw new Error("Invalid bech32m char");
    return v;
  });
  return { hrp, data };
}
function bech32mEncode(hrp, dataBytes) {
  function polymod(values) {
    const GEN = [0x3b6a57b2,0x26508e6d,0x1ea119fa,0x3d4233dd,0x2a1462b3];
    let chk = 1;
    for (let v of values) {
      let top = chk >> 25;
      chk = ((chk & 0x1ffffff) << 5) ^ v;
      for (let i = 0; i < 5; i++) if ((top >> i) & 1) chk ^= GEN[i];
    }
    return chk ^ 0x2bc830a3;
  }
  function expandHrp(hrp) {
    const ret = [];
    for (let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i) >> 5);
    ret.push(0);
    for (let i=0;i<hrp.length;i++) ret.push(hrp.charCodeAt(i) & 31);
    return ret;
  }
  const values = toWords(dataBytes);
  const checksum = polymod([...expandHrp(hrp), ...values, 0,0,0,0,0,0]);
  const chk = [];
  for (let i=0;i<6;i++) chk.push((checksum >> (5*(5-i))) & 31);
  const combined = [...values, ...chk];
  return hrp + '1' + combined.map(v=>CHARSET[v]).join('');
}
function arkToScriptHex(addr) {
  try {
    const { data } = bech32mDecode(addr);
    const full = fromWords(data);

    // Based on conversion tool logic
    const decoded = full.slice(0, 65); // Slice out the correct length for decoded
    if (decoded.length !== 65) {
      throw new Error("Invalid Ark address: incorrect length.");
    }

    const taprootKey = decoded.slice(33); // Slice out the precise taproot key
    return "5120" + toHex(taprootKey);
  } catch (e) {
    console.error("Conversion error:", e);
    return null;
  }
}

function isTxid(s) { return /^[0-9a-f]{64}$/i.test(s); }
function isScriptHex(s) { return /^5120[0-9a-f]{64}$/i.test(s); }
function isArkAddr(s) { return /^ark1[0-9a-z]{10,}$/i.test(s); }

async function explore() {
  const q = document.getElementById("search").value.trim();
  const out = document.getElementById("output");
  out.style.display = "block";
  out.innerHTML = `<p class="loading">Querying nodeâ€¦</p>`;

  try {
    if (isArkAddr(q)) {
      const script = arkToScriptHex(q);
      if (!script) throw new Error("Could not convert Ark address to script.");
      currentScriptHex = script;
      await fetchScriptData(script);
    } else if (isScriptHex(q)) {
      currentScriptHex = q;
      await fetchScriptData(q);
    } else if (isTxid(q)) {
      currentScriptHex = null;
      await fetchTxData(q);
    } else {
      out.innerHTML = `<p>Input not recognized as txid, script (5120...), or ark address. Got: <code>${escapeHtml(q)}</code></p>`;
    }
  } catch (e) {
    out.innerHTML = `<p style="color:#b00">Error: ${escapeHtml(e.message || e)}</p>`;
  }
}

function scriptToArk(scriptHex) {
  try {
    if (!scriptHex.startsWith("5120")) return null;
    const taprootHex = scriptHex.slice(4);
    const taprootKey = Uint8Array.from(taprootHex.match(/.{2}/g).map(b=>parseInt(b,16)));
    const serverKey = Uint8Array.from(SERVER_PUBKEY.slice(2).match(/.{2}/g).map(b=>parseInt(b,16)));
    const payload = new Uint8Array([0, ...serverKey, ...taprootKey]);
    return bech32mEncode("ark", payload);
  } catch (e) { return null; }
}

function isTxid(s) { return /^[0-9a-f]{64}$/i.test(s); }
function isScriptHex(s) { return /^5120[0-9a-f]{64}$/i.test(s); }
function isArkAddr(s) { return /^ark1[0-9a-z]{10,}$/i.test(s); }

function formatBigInt(bn) {
  const s = (typeof bn === "bigint") ? bn.toString() : String(bn);
  return s.replace(/\B(?=(\d{3})+(?!\d))/g, ",");
}

function escapeHtml(text) {
  return text.replace(/[&<>"']/g, function(m) {
    return { '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;' }[m];
  });
}

function toUTC(s) {
  try {
    let date;
    if (typeof s === "number" || /^\d+$/.test(s)) {
      let ts = Number(s);
      if (ts < 1e12) ts *= 1000;
      date = new Date(ts);
    } else {
      date = new Date(s);
    }
    return date.toISOString().replace('T',' ').replace('Z',' UTC');
  } catch {
    return s;
  }
}

let cachedVtxos = null;
let currentScriptHex = null;

async function explore() {
  const q = document.getElementById("search").value.trim();
  const out = document.getElementById("output");
  out.style.display = "block";
  out.innerHTML = `<p class="loading">Querying nodeâ€¦</p>`;

  try {
    if (isArkAddr(q)) {
      const script = arkToScriptHex(q);
      if (!script) throw new Error("Could not convert Ark address to script.");
      currentScriptHex = script;
      await fetchScriptData(script);
    } else if (isScriptHex(q)) {
      currentScriptHex = q;
      await fetchScriptData(q);
    } else if (isTxid(q)) {
      currentScriptHex = null;
      await fetchTxData(q);
    } else {
      out.innerHTML = `<p>Input not recognized as txid, script (5120...), or ark address. Got: <code>${escapeHtml(q)}</code></p>`;
    }
  } catch (e) {
    out.innerHTML = `<p style="color:#b00">Error: ${escapeHtml(e.message || e)}</p>`;
  }
}

async function fetchScriptData(scriptHex) {
  const out = document.getElementById("output");
  const params = new URLSearchParams();
  params.set("scripts", scriptHex);
  const url = VTXOS_ENDPOINT + "?" + params.toString();

  const res = await fetch(url);
  if (!res.ok) throw new Error("Node returned " + res.status);
  const json = await res.json();
  cachedVtxos = json.vtxos || [];
  displayScriptInfo(scriptHex, cachedVtxos);
}

async function fetchTxData(txid) {
  const out = document.getElementById("output");
  out.innerHTML = `<p class="loading">Probing vouts for tx ${txid}â€¦</p>`;
  let vout = 0, vtxos = [];
  while (true) {
    const url = VTXOS_ENDPOINT + "?outpoints=" + encodeURIComponent(txid + ":" + vout);
    const res = await fetch(url);
    if (!res.ok) throw new Error("Node returned " + res.status);
    const json = await res.json();
    if (!json.vtxos || json.vtxos.length === 0) break;
    vtxos.push(...json.vtxos);
    vout++;
    if (vout > 1000) break;
  }
  if (vtxos.length === 0) {
    out.innerHTML = `<p>No vtxos found for tx ${txid} (tried vouts 0..${vout-1}).</p>`;
    return;
  }
  cachedVtxos = vtxos;
  displayTxInfo(txid, vtxos);
}

function displayScriptInfo(scriptHex, vtxos) {
  const out = document.getElementById("output");
  refreshBalance();
}

function refreshBalance() {
  if (!cachedVtxos || !currentScriptHex) return;

  const out = document.getElementById("output");
  const spendableOnly = document.getElementById("spendableOnly").checked;
  const groupByCommitment = document.getElementById("groupByCommitment").checked;

  let sum = 0n, grouped = {};

  for (const v of cachedVtxos) {
    const pre = v.isPreconfirmed === true;
    const swept = v.isSwept === true;
    const unrolled = v.isUnrolled === true;
    const spent = v.isSpent === true;

    if (pre && !unrolled) {
      if (spendableOnly) {
        if (!swept && !spent) {
          sum += BigInt(v.amount || "0");
        }
      } else {
        if ((!swept && !spent) || (swept && spent)) {
          sum += BigInt(v.amount || "0");
        }
      }
    }

    if (groupByCommitment && v.commitmentTxids && v.commitmentTxids.length > 0) {
      const commitment = v.commitmentTxids[0];
      grouped[commitment] = grouped[commitment] || [];
      grouped[commitment].push(v);
    }
  }

  const address = scriptToArk(currentScriptHex) || "(cannot reconstruct ark address)";

  let html = `<h2>Script Info</h2>
  <p><b>Ark Address:</b> ${escapeHtml(address)}</p>
  <p><b>ScriptPubKey:</b> <code>${escapeHtml(currentScriptHex)}</code></p>
  <p class="muted">
    Balance sums vtxos where <code>isPreconfirmed:true</code>, <code>isUnrolled:false</code> and:<br/>
    <ul>
      <li><b>Only spendable checked:</b> <code>isSwept:false & isSpent:false</code></li>
      <li><b>Unchecked:</b> both <code>isSwept:false & isSpent:false</code> and <code>isSwept:true & isSpent:true</code></li>
    </ul>
  </p>
  <p><b>Total Balance:</b> ${formatBigInt(sum)} sats</p>`;

  if (groupByCommitment) {
    for (let commitment in grouped) {
      html += `<table>
        <thead>
          <tr>
            <th colspan="4" class="chevron" onclick="toggleGroup('${commitment}')">
              <span>â–¶</span> Onchain Commitment Transaction 
              <a href="https://mempool.space/tx/${commitment}" target="_blank" rel="noopener noreferrer">${escapeHtml(commitment)}</a>
            </th>
          </tr>
          <tr id="${commitment}-header" class="hidden"><th>Outpoint</th><th>Amount</th><th>Created (UTC)</th><th>Status</th></tr>
        </thead>
        <tbody id="${commitment}" class="hidden">`;

      grouped[commitment].forEach(v => {
        const amt = BigInt(v.amount || "0");
        const created = v.createdAt ? toUTC(v.createdAt) : "-";
        const flags = [];
        if (v.isSpent) flags.push("Spent");
        if (v.isSwept) flags.push("Swept");
        if (v.isUnrolled) flags.push("Unrolled");
        if (v.isPreconfirmed) flags.push("Preconfirmed");
        const status = flags.length ? flags.join(", ") : "Unspent";
        html += `<tr>
          <td><a href="https://bitcoin-beta.arkade.sh/v1/vtxos?outpoints=${encodeURIComponent(v.outpoint.txid + ':' + v.outpoint.vout)}" target="_blank" rel="noopener noreferrer"><code>${escapeHtml(v.outpoint.txid)}:${v.outpoint.vout}</code></a></td>
          <td>${formatBigInt(amt)} sats</td>
          <td class="muted">${created}</td>
          <td>${escapeHtml(status)}</td>
        </tr>`;
      });
      html += `</tbody></table>`;
    }
  } else {
    html += `<table><thead><tr><th>Outpoint</th><th>Amount</th><th>Created (UTC)</th><th>Status</th><th>Commitment TX</th></tr></thead><tbody>`;
    for (const v of cachedVtxos) {
      const amt = BigInt(v.amount || "0");
      const created = v.createdAt ? toUTC(v.createdAt) : "-";
      const flags = [];
      if (v.isSpent) flags.push("Spent");
      if (v.isSwept) flags.push("Swept");
      if (v.isUnrolled) flags.push("Unrolled");
      if (v.isPreconfirmed) flags.push("Preconfirmed");
      const status = flags.length ? flags.join(", ") : "Unspent";
      html += `<tr>
        <td><a href="https://bitcoin-beta.arkade.sh/v1/vtxos?outpoints=${encodeURIComponent(v.outpoint.txid + ':' + v.outpoint.vout)}" target="_blank" rel="noopener noreferrer"><code>${escapeHtml(v.outpoint.txid)}:${v.outpoint.vout}</code></a></td>
        <td>${formatBigInt(amt)} sats</td>
        <td class="muted">${created}</td>
        <td>${escapeHtml(status)}</td>
        <td>${v.commitmentTxids && v.commitmentTxids.length > 0 ? `<a href="https://mempool.space/tx/${escapeHtml(v.commitmentTxids[0])}" target="_blank" rel="noopener noreferrer">${escapeHtml(v.commitmentTxids[0])}</a>` : "-"}</td>
      </tr>`;
    }
    html += `</tbody></table>`;
  }

  out.innerHTML = html;
}

function displayTxInfo(txid, vtxos) {
  const out = document.getElementById("output");
  const groupByCommitment = document.getElementById("groupByCommitment").checked;
  let html = `<h2>Transaction Output Info</h2>
    <p><b>TxID:</b> ${escapeHtml(txid)}</p>`;

  if (groupByCommitment) {
    let grouped = {};
    vtxos.forEach(v => {
      if (v.commitmentTxids && v.commitmentTxids.length > 0) {
        const commitment = v.commitmentTxids[0];
        grouped[commitment] = grouped[commitment] || [];
        grouped[commitment].push(v);
      }
    });

    for (let commitment in grouped) {
      html += `<table>
        <thead>
          <tr>
            <th colspan="4" class="chevron" onclick="toggleGroup('${commitment}')">
              <span>â–¶</span> Onchain Commitment Transaction 
              <a href="https://mempool.space/tx/${commitment}" target="_blank" rel="noopener noreferrer">${escapeHtml(commitment)}</a>
            </th>
          </tr>
          <tr id="${commitment}-header" class="hidden"><th>Outpoint</th><th>Amount</th><th>Created (UTC)</th><th>Status</th></tr>
        </thead>
        <tbody id="${commitment}" class="hidden">`;

      grouped[commitment].forEach(v => {
        const amt = BigInt(v.amount || "0");
        const created = v.createdAt ? toUTC(v.createdAt) : "-";
        const flags = [];
        if (v.isSpent) flags.push("Spent");
        if (v.isSwept) flags.push("Swept");
        if (v.isUnrolled) flags.push("Unrolled");
        if (v.isPreconfirmed) flags.push("Preconfirmed");
        const status = flags.length ? flags.join(", ") : "Unspent";
        html += `<tr>
          <td><a href="https://bitcoin-beta.arkade.sh/v1/vtxos?outpoints=${encodeURIComponent(v.outpoint.txid + ':' + v.outpoint.vout)}" target="_blank" rel="noopener noreferrer"><code>${escapeHtml(v.outpoint.txid)}:${v.outpoint.vout}</code></a></td>
          <td>${formatBigInt(amt)} sats</td>
          <td class="muted">${created}</td>
          <td>${escapeHtml(status)}</td>
        </tr>`;
      });
      html += `</tbody></table>`;
    }
  } else {
    html += `<table><thead><tr><th>Outpoint</th><th>Amount</th><th>Created (UTC)</th><th>Status</th><th>Commitment TX</th></tr></thead><tbody>`;
    for (const v of vtxos) {
      const amt = BigInt(v.amount || "0");
      const created = v.createdAt ? toUTC(v.createdAt) : "-";
      const flags = [];
      if (v.isSpent) flags.push("Spent");
      if (v.isSwept) flags.push("Swept");
      if (v.isUnrolled) flags.push("Unrolled");
      if (v.isPreconfirmed) flags.push("Preconfirmed");
      const status = flags.length ? flags.join(", ") : "Unspent";
      html += `<tr>
        <td><a href="https://bitcoin-beta.arkade.sh/v1/vtxos?outpoints=${encodeURIComponent(v.outpoint.txid + ':' + v.outpoint.vout)}" target="_blank" rel="noopener noreferrer"><code>${escapeHtml(v.outpoint.txid)}:${v.outpoint.vout}</code></a></td>
        <td>${formatBigInt(amt)} sats</td>
        <td class="muted">${created}</td>
        <td>${escapeHtml(status)}</td>
        <td>${v.commitmentTxids && v.commitmentTxids.length > 0 ? `<a href="https://mempool.space/tx/${escapeHtml(v.commitmentTxids[0])}" target="_blank" rel="noopener noreferrer">${escapeHtml(v.commitmentTxids[0])}</a>` : "-"}</td>
      </tr>`;
    }
    html += `</tbody></table>`;
  }

  out.innerHTML = html;
}

function toggleGroup(commitment) {
  const rows = document.getElementById(commitment);
  const header = document.getElementById(`${commitment}-header`);
  const chevron = header.previousElementSibling.querySelector('span');
  const isHidden = rows.classList.contains('hidden');
  rows.classList.toggle('hidden', !isHidden);
  header.classList.toggle('hidden', !isHidden);
  chevron.textContent = isHidden ? 'â–¼' : 'â–¶';
}

</script>
</body>
</html>
